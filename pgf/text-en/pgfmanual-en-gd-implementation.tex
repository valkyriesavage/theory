% Copyright 2010-2011 by RenÃ©e Ahrens
% Copyright 2010-2011 by Olof Frahm
% Copyright 2010-2011 by Jens Kluttig
% Copyright 2010-2011 by Matthias Schulz
% Copyright 2010-2011 by Stephan Schuster
% Copyright 2011 by Jannis Pohlmann
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Implementing Graph Drawing Algorithms: The \TeX\ Side}

{\noindent {\itshape{Original by Ren\'ee Ahrens, Olof-Joachim Frahm, Jens Kluttig,
  Matthias Schulz, Stephan Schuster\par\noindent Rewritten by Till Tantau}}}

\label{section-base-graphdrawing}
\label{section-gd-internals}

File status: Layout management has changed, this is not reflected by
the contents of this file...


\begin{pgflibrary}{graphdrawing}
  This package provides the \TeX\ interface to the graph drawing
  engine. Since it uses \LuaTeX, you need at least \LuaTeX\ 0.45 or 
  higher.
\end{pgflibrary}

\begin{tikzlibrary}{graphdrawing}
  This library is what users will usually load. It loads the above
  library automatically. Nevertheless, the graph drawing engine can be
  used independently of \tikzname.
\end{tikzlibrary}


This chapter explains the technical details of how the \TeX\ layer
communicates with the Lua side of the graph drawing engine. A note of
caution:

\begin{quote}
  \itshape You do not need to understand the details of this
  chapter to write new graph drawing algorithms. It is of interest
  only to those wishing to extend the syntactic features of the \TeX\ side
  of the graph drawing engine.
\end{quote}


\subsection{The Call Graph of the Graph Drawing Engine}

Let us start with the broad picture. The general idea behind the whole
graph drawing engine is that whenever \pgfname\ creates a node, we
intercept this node creation and \emph{do not} immediately place the
node. Rather, we pass it down to Lua, which tucks it away in
some internal tables. For edges, we introduce a special command called
|\pgfgdedge| that tells Lua that there is an edge between two
tucked-away nodes. Then, after the graph has been completely
specified, a graph drawing algorithm written in Lua starts to work on
the graph by computing new positions for the nodes. Then, the graph
drawing engine will send back the nodes and edges to \pgfname, which
then finally places them at their final positions.
Note that graph drawing algorithms need no knowledge of how any of
these internals work.

Let us have a look at a simple example to see what happens when a
graph is specified:

\begin{codeexample}[]
\tikz[tree layout]
  \graph {root [as=Hello] -> World[fill=blue!20]};
\end{codeexample}

The key |tree layout| internally calls the key |graph drawing scope|,
which in turn calls the macro |\pgfgdbeginscope|, which starts up the
graph drawing engine. Once this macro has been 
called, until the next call of |\pgfgdendscope|, all nodes that are
created actually get passed down to the graph drawing engine. This is
implemented on the lowest layer, namely by directly intercepting
nodes freshly created using |\pgfnode|. In our example, this happens
in two places: For the |root| node and for the |World| node. The
|graph| library and \tikzname\ internally call the |\pgfnode| macro
for these two nodes (after a large number of internal syntax
translations, but the graph drawing engine does not care about them).

Note that the node boxes will have been fully created before they are
passed down to the graph drawing engine -- only their final position
is not yet fixed. It is not possible to modify the size of nodes
inside the graph drawing engine. 

In contrast, the single edge of the graph that is created by the |->|
command is not fully created before it is passed down to the
engine. This would not really make sense since before the final
positions of the nodes are fixed, we cannot even begin to compute the
length of this edge, let alone where it should start or end. For this
reason, on the upper \tikzname\ layer, the normal edge creation that
would be caused by |->| via |new ->| is suppressed. Instead, the
command |\pgfgdedge| is called. Similarly, inside a graph drawing
scope, \tikzname\ will suppress both the |edge| and the
|edge from parent| command and cause |\pgfgdedge| to be called
instead. 

An overview of what happens is illustrated by the following call graph:

\begin{tikzpicture}[
    class name/.style={draw,minimum size=20pt, fill=blue!20},
    object node/.style={draw,minimum size=15pt, fill=yellow!20},
    p/.style={->,>=spaced stealth'},
    livespan/.style={very thick},
    xscale=0.8]
  % class names above
  \node (tikz) at (0,4) [class name] {\tikzname\ layer};
  \node (tex) at (6,4) [class name] {\pgfname\ layer};
  \node (interface) at (13,4) [class name] {Lua: TeXInterface};
  % lines from the class names to the bottom of the picture
  \draw[livespan] (tikz) -- (0,-6.5);
  \draw[livespan] (tex) -- (6,-6.5);
  \draw[livespan] (interface) -- (13,-6.5);
  % first command: \graph{  -- generates new graph in lua interface
  \node (tikz-begin-graph) at (0,3) [object node] {|\graph[algorithm=...]{|}; %}
  \node (tex-begin-graph) at (6,3) [object node] {|\pgfgdbeginscope|};  
  \node (interface-new-graph) at (13,3) [object node] {|beginGraphDrawingScope(|...|)|};
  \draw [p] (tikz-begin-graph.east) -- (tex-begin-graph.west);
  \draw [p] (tex-begin-graph.east) -- (interface-new-graph.west);    
  % second command: a -> b   -- generates two nodes in lua
  % and one edge
  \node (tikz-node) at (0,2) [object node] {|a -> b;|};
  \node (tex-node) at (6,2) [object node, double copy shadow] {|\pgfnode|};
  \draw[p] (tikz-node.east) -- (tex-node.west);
  
  \node (interface-add-node) at (13,2) [object node, double copy shadow] {|addPgfNode(|...|)|};
  \draw[p] (tex-node.east) -- (interface-add-node.west);

  \node (tex-add-edge) at (6,1) [object node, double copy shadow] {|\pgfgdedge|};
  \node (interface-add-edge) at (13,1) [object node, double copy shadow] {|addPgfEdge(|...|)|};
  \draw[p] (tikz-node.east) -- (1.5,2) -- (1.5,1) -- (tex-add-edge.west);
  \draw[p] (tex-add-edge.east) -- (interface-add-edge.west);

  % scope ends -- cloes graph, layouts it and draws it
  \node (tikz-end) at (0,0) [object node] {|};|};
  \node (tex-end) at (6,0) [object node] {|\pgfgdendscope|};
  \node (interface-draw-graph) at (13,0) [object node] {|runGraphDrawingAlgorithm()|};
  \node (interface-finish-graph) at (13,-2) [object node] {|endGraphDrawingScope()|};

  \node (invoke-algorithm) at (15.5,-1) [object node] {invoke algorithm};
  \draw[p] (tikz-end.east) -- (tex-end.west);
  \draw[p] (tex-end.east) -- (interface-draw-graph.west);
  \draw[p] (interface-draw-graph.east) -| (invoke-algorithm.20);
  \draw[p] (tex-end.east) -- (9.5,0) -- (9.5,-2) -- (interface-finish-graph.west);

  % begin shipout
  \node (tex-begin-shipout) at (6,-3) [object node] {|\pgfgdbeginshipout|};

  \node (tex-puttexbox) at (6,-4) [object node, double copy shadow] {|\pgfpositionnodenow|};
  \node (tex-putedge) at (6,-5) [object node, double copy shadow] {|\pgfgdedgecallback|};
  
  \node (tex-end-shipout) at (6,-6) [object node] {|\pgfgdendshipout|};
  
  \draw [p] (interface-finish-graph.-170) |- (tex-begin-shipout.east);
  \draw [p] (interface-finish-graph.-170) |- (tex-puttexbox.east);
  \draw [p] (interface-finish-graph.-170) |- (tex-putedge.east);
  \draw [p] (interface-finish-graph.-170) |- (tex-end-shipout.east);
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-4) -- (sys-puttexbox.west);

  % put edge
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-5) -- (sys-put-edge.west);
  % end shipout
  %(interface-finish-graph.east) -- (12.5,-2) -- (12.5,-6) -- (sys-end-shipout.west);
\end{tikzpicture}

In Section~\ref{section-gd-scopes} we detail the different commands
needed to communicate with the graph drawing engine. In particular,
the commands for beginning and ending scopes are explained here. The
next section, Section~\ref{section-gd-parameters} explains how graph
parameters are setup and configured.


\subsection{Graph Drawing Scopes}
\label{section-gd-scopes}

\subsubsection{The Main Graph Drawing Scope}

\begin{command}{\pgfgdbeginscope}
  This macro starts a \TeX\ scope. The following things will happen:
  \begin{enumerate}
  \item A new |scope| object is created and put on an internal stack
    of scopes. All subsequent operations will work on this graph until
    |\pgfgdendscope| is called. In particular, it is permissible to
    have nested graph drawing scopes.
  \item Inside the scope, no nodes are placed immediately. Rather, 
    the macro |\pgfpositionnodelater|, see
    Section~\ref{section-shapes-deferred-node-positioning}, is used to
    send all nodes created inside the scope to some internal collector
    macro. This internal collector macro will pass down the created
    node to Lua.
  \item Some additional \meta{code} is executed, which has been set
    using the following command:
    \begin{command}{\pgfgdaddspecificationhook\marg{code}}
      This command adds the \meta{code} to the code that is executed
      whenever a graph drawing scope starts. For instance, the
      \tikzname\ library |graphdrawing| uses this macro to add some
      \meta{code} that will redirect the |edge| and |edge from parent|
      path commands to |\pgfgdedge|.
    \end{command}
  \item |\pgftransformreset| is called. See
    Section~\ref{section-gd-lua-coordinates} for details on the effect
    of this.
  \item The following \TeX-if is set to true:
    {
      \let\ifpgfgdgraphdrawingscopeactive=\relax
      \begin{textoken}{\ifpgfgdgraphdrawingscopeactive}
        Will be true inside a graph drawing scope.
      \end{textoken}
    }
  \end{enumerate}
  The above has a number of consequences for what can happen inside a
  graph drawing scope:
  \begin{itemize}
  \item Since no nodes are actually created before the end of the
    scope, you cannot reference these nodes. Thus, you cannot write
\begin{codeexample}[code only]
\tikz [spring layout] {
  \node (a) {a};
  \node (b) {b};
  \draw (a) -- (b);
}
\end{codeexample}
    The problem is that we cannot connect |(a)| and |(b)| via a
    straight line since these nodes do not exist at that point (they
    are available only deeply inside the Lua layer).
  \item In order to create edges between nodes inside a graph drawing
    scope, you need to call the |\pgfgdedge| command, described below.
  \end{itemize}
\end{command}


\begin{command}{\pgfgdendscope}
  This macro is used to end a graph drawing scope. It must be given on
  the same \TeX\ grouping level as the corresponding
  |\pgfgdbeginscope|. When the macro is called, it triggers a lot of
  new calls:
  \begin{enumerate}
  \item The special treatment of newly created boxes is ended. Nodes
    are once more created normally.
  \item The effects of the \meta{code} that was inserted via the
    specification hook command also ends (provided it had no global
    effects).
  \item Then, on the Lua layer, the graph drawing algorithm is
    started. The hierarchy of layouts processed as described in
    Section~\ref{section-gd-layout-scopes} below.
  \item When the processing has finished, a so-called \emph{shipout
      phase} is started.
  \item During this phase, all nodes that were intercepted during the
    graph drawing scope get inserted into the output stream at the
    positions that were computed for them. Also, for each edge that
    was requested via |\pgfgdedge|, the macro |\pgfgdedgecallback| is
    called (see below).
  \item Finally, the shipout phase is finished, the scope is popped
    from the scope stack and the \TeX\ scope is ended. 
  \end{enumerate}
\end{command}



\subsubsection{Layout Scopes}

\label{section-gd-layout-scopes}

As described in Section~\ref{section-gd-sublayouts}, the graph drawing
engine does not always apply only a single algorithm. Rather, several
different algorithm may be applied to different parts of the
graph. How this happens, exactly, is goverened by a hierarchy of
layouts, which are setup using the following command:

\begin{command}{\pgfgdlayout}
  NO LONGER CORRECT.
  
  This command can only be used inside a graph drawing scope. It will
  start a \emph{layout}, which will end at the end of the current \TeX\
  scope. All nodes and edges mentioned inside a layout will become
  part of a collection of kind |layout|.

  When a layout is created inside another layout (that is, when 
  |\pgfgdlayout| is called again before the end of the current scope),
  the second layout becomes a \emph{sublayout} of the first 
  layout, resulting in a hierarchy of layouts. In such cases, nodes
  and edges mentioned inside the second layout are also part of the
  first layout.

  In order to make a node part of two different layouts that are not
  nested in one another, use the |\pgfgdsetlatenodeoption| command
  (this command is called automatically by |node also| and when you
  reference a node several times in a |graph| path command, so,
  usually, you do not need to this yourself).

  The current set of graph drawing options is used to determine which
  algorithm should be used to lay out the nodes of the layout.
\end{command}


Document:

layout node name/.graph parameter=string,
layout node text/.graph parameter=string,
layout node options/.graph parameter=string,
layout point cloud/.initial=,
layout bounding box width/.initial=,
layout bounding box height/.initial=,
layout text/.initial=,
start layout node/.style=



\subsubsection{Algorithm Selection}

\begin{key}{/graph drawing/algorithm=\meta{algorithm's name}}
  \label{section-gd-algorithm-key}%
  This key specifies which algorithm should be used for typesetting a
  graph. The names of these algorithm's are often a bit cryptic (like
  |pgf.gd.force.SpringElectricalWalshaw2000| or something similar),
  which is why you typically do not call this key directly. Instead,
  styles with more easy-to-remember names internally set this key.

  Setting this key has the following effects: During the execution of
  |\pgfgdendscope|, Lua will say |require(|\meta{algorithm's name}|)|.
  This call of Lua's |require| method must now return a class object,
  which should typically have been created using the
  |pgf.gd.new_algorithm_class| command; see the documentation of
  |require| for details on what happens here. Provided the class is
  found (otherwise an error is raised), an object of the class is
  instantiated and its |run| method is called. The object's |digraph|
  and |ugraph| fields will have been set to the directed graph and the
  undirected graph underlying the syntactic digraph.
  
  Here is an example where we switch on the graph drawing engine
  explicitly and explicitly select an algorithm:
\begin{codeexample}[]
\tikz [/graph drawing/request scope and layout,
       /graph drawing/algorithm=pgf.gd.force.SpringElectricalWalshaw2000]
  \graph { a <-> {b, c} };  
\end{codeexample}
  The reference of the available algorithms is in
  Sections~\ref{section-first-graphdrawing-library-in-manual} to 
  \ref{section-last-graphdrawing-library-in-manual}.
\end{key}


\subsubsection{Handling of Edges}

Inside a graph drawing scope, nodes are
automatically passed down to the graph drawing engine, while for edges
a command has to be called explicitly:

\begin{command}{\pgfgdedge\marg{first node}\marg{second
      node}\marg{edge direction}\marg{edge options}\marg{edge nodes}}
  This command is used to tell the graph drawing engine that there is
  an edge between \meta{first node} and \meta{second node} in your
  graph. The ``kind'' of connection is indicated by \meta{direction},
  which may be one of the following:
  \begin{itemize}
  \item 
    |->| indicates a directed edge (also known as an arc) from
    \meta{first node} to \meta{second node}.
  \item |--| indicates an undirected edge between \meta{first node}
    and \meta{second node},
  \item |<-| indicates a directed edge from \meta{second node} to
    \meta{first node}, but with the ``additional hint'' that this is a
    ``backward'' edge. A graph drawing algorithm may  or may not take
    this hint into account.
  \item |<->| indicates a bi-directed edge between \meta{first node}
    and \meta{second node}. 
  \item |-!-| indicates that the edge from \meta{first node} to
    \meta{second node} is ``missing''. 
  \end{itemize}
  Note that in all cases, the syntatic digraph will contain an arc
  from \meta{first node} to \meta{second node}, regardless of the
  value of \meta{direction}. The \meta{direction} is ``just'' a
  ``semantic annotation''.
  
  The parameters \meta{edge options} and \meta{edge nodes} are a bit
  more tricky. When an edge between two vertices of a graph is created
  via |\pgfgdedge|, nothing is actually done immediately. After all,
  without knowing the final positions of the nodes \meta{first node}
  and \meta{second node}, there is no way of creating the actual
  drawing commands for the edge. Thus, the actual drawing of the edge
  is done only when the graph drawing algorithm is done (namely in the
  macro |\pgfgdedgecallback|, see later). 

  Because of this ``delayed'' drawing of edges, options that influence
  the edge must be retained until the moment when the edge is actually
  drawn. Parameters \meta{edge options} and \meta{edge nodes} store such
  options. 

  Let us start with \meta{edge options}. This parameter should be set
  to a list of key-value pairs like
\begin{codeexample}[code only]
/tikz/.cd, color=red, very thick, this edge must be vertical
\end{codeexample}
  Some of these options may be of interest to the graph drawing
  algorithm (like the last option) while others will 
  only be important during the drawing of edge (like the first
  option). The options that are important for the graph drawing
  algorithm must be passed to the algorithm via setting keys that have
  been declared using the handler |.edge parameter|, see
  Section~\ref{section-gd-parameters}. 

  The tricky part is that options that are of interest to the graph
  drawing algorithm must be executed \emph{before} the algorithm starts,
  but the options as a whole are usually only executed during the
  drawing of the edges, which is \emph{after} the algorithm has finished.
  To overcome this problem, the following happens:

  The options in \meta{edge options} are executed ``tentatively'' inside
  |\pgfgdedge|. However, this execution is done in a ``heavily guarded
  sandbox'' where all effects of the options (like changing the
  color or the line width) do not propagate beyond the sandbox. Only
  the changes of the graph drawing edge parameters leave the
  sandbox. These parameters are then passed down to the graph drawing
  engine.

  Later, when the edge is drawn using |\pgfgdedgecallback|, the
  options \meta{edge options} are available once more and then they
  are executed normally.

  Note that when the options in \meta{edge options} are executed, no
  path is preset. Thus, you typically need to start it with, say,
  |/tikz/.cd|. Also note that the sandbox is not perfect and changing
  global values will have an effect outside the sandbox. Indeed,
  ``putting things in a sandbox'' just means that the options are
  executed inside a \TeX\ scope inside an interrupted path inside a
  \TeX\ box that is thrown away immediately. 
  
  The text in \meta{edge nodes} is some ``auxilliary'' text that is
  simply stored away and later directly to |\pgfgdedgecallback|. This
  is used for instance by \tikzname\ to store its node labels. 
\end{command}


\begin{command}{\pgfgdsetedgecallback\marg{macro}}
  This command allows you to change the \meta{macro} that gets called
  form inside the graph drawing engine at the end of the creation of a
  graph, when the nodes have been positioned. The \meta{macro} will be 
  called once for each edge with the following parameters:
  \begin{quote}
    \meta{macro}\marg{first node}\marg{second
      node}\marg{direction}\marg{edge options}\marg{edge
      nodes}\marg{algorithm-generated options}\marg{bend information} 
  \end{quote}

  The first five parameters are the original values that were passed
  down to the |\pgfgdedge| command.
  
  The \meta{algorithm-generated options} have been ``computed by the
  algorithm''. For instance, an algorithm might have determined, say,
  flow capacities for edges and it might now wish to communicate this
  information back to the upper layers. These options should be
  executed with the path |/graph drawing|.
  
  The parameter \meta{bend information} contains
  algorithmically-computed information concerning how the 
  edge should bend. Currently, this will be a text like
  |(10pt,20pt)--(30pt,40pt)| in \tikzname-syntax, but this may change
  to make things more portable.

  The default \meta{macro} simply draws a line between the nodes. When
  the |graphdrawing| library of the \tikzname\ layer is loaded, a more
  fancy \meta{macro} is used that takes all of the parameters into
  account.
\end{command}



\subsubsection{Frontend Keys}

Users of the graph drawing engine typically use a key like
|tree layout| to specify a graph drawing algorithm. This key is
actually just a style that uses the key |graph drawing scope|, which
in turn calls the macro |\pgfgdbeginscope|:

\begin{key}{/tikz/graph drawing scope}
  This key can (only) be used as an option when a \tikzname\ scope is
  started. Thus, you can pass it to |\tikz|, to |{tikzpicture}|, to
  |\scoped|, to |{scope}|, to |graph|, and to |{graph}|. For instance,
  the |tree layout| option (which uses |graph drawing scope| internally) can
  be used in the following ways:
\begin{codeexample}[]
\tikz [tree layout] \graph        {1 -> {b,c}};  
\tikz \graph [tree layout]        {2 -> {b,c}};
\tikz \path graph [tree layout]   {3 -> {b,c}};

\begin{tikzpicture}[tree layout]
  \graph                          {4 -> {b,c}};
\end{tikzpicture}

\begin{tikzpicture}
  \scoped [tree layout] \graph    {5 -> {b,c}};
    
  \begin{scope}[tree layout, xshift=1.5cm]
    \graph                        {6 -> {b,c}};
  \end{scope}
\end{tikzpicture}
\end{codeexample}

  You can \emph{not} use the |graph drawing scope| key with a single
  node or on a path. In particular, to typeset a tree given in the
  |child| syntax somewhere inside a |{tikzpicture}|, you must prefix
  it with the |\scoped| command:
\begin{codeexample}[]
\begin{tikzpicture}
  \scoped [tree layout]
    \node {root}
    child { node {left child} }
    child { node {right child} };
\end{tikzpicture}
\end{codeexample}
  Naturally, the above could have been written more succinctly as
\begin{codeexample}[]
\tikz [tree layout]
  \node {root}
  child { node {left child} }
  child { node {right child} };
\end{codeexample}
  Or even more succinctly:
\begin{codeexample}[]
\tikz \graph [tree layout] { root -- {left child, right child} };
\end{codeexample}

  In detail, adding the |graph drawing scope| command to a scope has
  the following effects:
  \begin{itemize}
  \item The basic layer is informed, using the
    |execute at begin scope| key, that the current scope will contain
    nodes that should be positioned by a graph drawing engine. Which
    algorithm is used depends on the value of the |algorithm| key.
  \item If the |graphs| library has been loaded, the default
    positioning mechanisms of this library are switched off, leaving
    the positioning to the graph drawing engine. Also, when an edge is
    created by the |graphs| library, this is signalled to the graph
    drawing library. (To be more precise: The keys |new ->| and so on
    are redefined so that they call |\pgfgdedge| instead of creating
    an edge.
  \item The |edge| path command is modified so that it also calls
    |\pgfgdedge| instead of immediately creating any edges.
  \item The |edge from parent| path command is modified so that is
    also calls |\pgfgdedge|.
  \item The keys |append after command| and |prefix after command|
    keys are modified so that they are executed only via
    |late options| when the node has ``reached its final parking
    position''. 
  \end{itemize}
\end{key}

\begin{key}{/tikz/layout=\meta{algorithm}}
  \keyalias{tikz/graphs}
  A shorthand for saying |graph drawing scope| and then
  |algorithm=|\meta{algorithm}. This key is mainly for demonstration
  purposes, usually you should declare algorithms using the
  |\pgfgddeclarealgorithmkey| macro.
\end{key}



\subsection{Parameters}
\label{section-gd-parameters}

When a graph drawing algorithm starts working, a set of options,
called ``graph drawing parameters'' or just ``parameters'' (in
constrast to ``options'') in the following, can influence
the way the algorithm works. For instance, a graph drawing parameter
might be the average distance between vertices which the algorithm
should take into account. Another example might be the fact the
certain nodes are special nodes and that a certain edge should have
a large label.

These graph drawing parameters are different from ``usual'' \pgfname\
options: An alogrithmic parameter influences the way the algorithm
works, while usual options influence the way the result
looks like. For instance, the fact that a node is red is not a
graph drawing parameter, while the shape of a node might be an graph
drawing parameter. 

Graph parameter should usually be keys with a path starting with
|/graph drawing| (although, strictly speaking, this is not
necessary). The following command makes it a bit easier to set them:
\begin{command}{\pgfgdset\marg{options}}
  Executes the \meta{options} with the path |/graph drawing|.  
\end{command}

There are three kinds of graph drawing parameters:

\begin{itemize}
\item \emph{Graph parameters:}
  These parameters influence ``the whole graph''. An example
  is the distance between vertices on the same level of a tree.
\item \emph{Node parameters:}
  These parameters are ``attached'' to a single node. This includes
  options that are only meaningful in the context of a graph
  drawing algorithm (like, say, the ``mass'' of a node in a
  force-based algorithm), but also hybrid attributed like the shape
  of a node. The shape is important for \pgfname\ when it typesets the 
  node, but it may also be important for the graph drawing
  algorithm since it might position circles differently from, say,
  rectangles.
\item \emph{Edge parameters:}
  Similarly to nodes, edges can also have graph drawing
  parameters. Also similarly to nodes, there can be purely
  graph drawing parameters and also options that are hybrid.
\end{itemize}
   
You have to ``declare'' a graph drawing parameter similarly to a
normal key, but instead of using the |.code| handler, you use
\begin{itemize}
\item |.graph parameter|,
\item |.node parameter|, and
\item |.edge parameter|.
\end{itemize}

Specifying the set of graph drawing parameters for a given graph or
node or edge works as follows: When the graph drawing engine is
started for a graph (using |\pgfgdbeginscope|), a snapshot is taken of
all graph drawing graph parameters currently setup at this
point. Similarly, when a node is created inside such a scope (using
|\pgfnode|), a snapshot is taken of the set of all graph drawing node
parameters in force at this point and stored together with
the node. Finally, when an edge is created (using |\pgfgdedge|), a
snapshot of the setting of the graph drawing edge parameters is
taken. 

The options set in this way can later be access from the Lua code via
the |options| fields of digraphs, vertices, and arcs. (For arcs, the
situation is a bit more involved, but most of the time, you can access
the option as expected.)

In addition to the above kind of parameters, there are also two
``hybrid'' kind of parameter: ``Node or graph'' parameters and ``edge
or graph'' parameters. The idea behind these parameters is the
following: If such a parameter is specified before a graph
specification, it becomes a graph parameter; if it is specified inside
a graph specification is becomes a node or edge parameter. As an
example, the |sibling distance| is normally a graph parameter (because
it applies to all nodes), but it becomes a node parameter when given
to a single node.


\subsubsection{Basic Commands For Setting Parameters}

Let us start with the basic commands for setting a graph parameter
(although you typically will not call these commands directly).

\begin{command}{\pgfgdgraphparameter\marg{graph
      parameter}\marg{value}} 
  Sets the \meta{graph parameter} inside the local \TeX\ scope to
  \meta{value}. When |\pgfgdbeginscope| is encountered,
  the current settings of all graph parameters that have been set
  using this command will be passed down to the graph drawing
  engine. (Note that this happens right at the beginning of the graph
  drawing scope.)

  Inside a graph drawing algorithm, you can access to \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = graph.options['<graph parameter>']
\end{codeexample}
  where |<graph parameter>| should be the exact text passed as
  \meta{graph parameter}.

  In case that a graph parameter has not been set, the |options| field
  will be |nil| (but see also the description of the
  |.parameter initial| handler below).

  Note that the \meta{value} will be passed down directly to Lua
  without being quoted. Thus, if \meta{value} is |42|, you will get a
  Lua |number| inside |myvalue|, while if \meta{value} is |'42'|, you
  get a Lua |string|, and if \meta{value} is |1cm|, you get an error.
\end{command}


\begin{command}{\pgfgdnodeparameter\marg{node
      parameter}\marg{value}} 
  Sets the \meta{node parameter} inside the local \TeX\ scope to
  \meta{value}. Unlike for graph parameter, it also makes sense to
  call this command deep inside a graph drawing scope. When a
  |\pgfnode| command is is encountered, the current settings of all
  node parameters that have been set using this command will be passed
  down to the graph drawing engine and will be stored alongside the
  node. 

  Inside a graph drawing algorithm, you can access \meta{value} as
  follows:
\begin{codeexample}[code only]
  local myvalue = vertex.optoins['<node parameter>']
\end{codeexample}
\end{command}

\begin{command}{\pgfgdedgeparameter\marg{edge
      parameter}\marg{value}} 
  Works like |\pgfgdnodeparameter|, only for edges. Unlike for node
  and graph parameters, you cannot always just write 
\begin{codeexample}[code only]
  local myvalue = arc.options['<edge parameter>']
\end{codeexample}
  The reason is the an arc often represents multiple edges and, thus,
  some kind of ``collecting'' needs to be done how the (multiple)
  values that an option may have for a single arc should be
  aggregated. See Section~\ref{section-gd-arc-model} for more
  details. 
\end{command}

\begin{command}{\pgfgdhybridnodegraphparameter\marg{parameter}\marg{value}}
  Calls |\pgfgdnodeparameter| when inside a graph drawing scope,
  otherwise |\pgfgdgraphparameter|.  
\end{command}

\begin{command}{\pgfgdhybridedgegraphparameter\marg{parameter}\marg{value}}
  As above, but for edges.
\end{command}



\subsubsection{Key Handlers  For Setting Parameters}

In practice, you do not call the above commands directly. Instead, you
use key handlers that will take care of calling these commands
internally.

\begin{handler}{{.graph parameter}|=|\meta{conversion}}
  When this key hanlder is applied to a key, this key ``becomes a
  graph drawing graph parameter''. Subsequently, assigning a value to
  the key will cause an appropriate call of |\pgfgdgraphparameter| to
  be issued. For instance, suppose we say
\begin{codeexample}[code only]
\pgfkeys{/some path/my key/.graph parameter=string}
\end{codeexample}
  and then subsequently
\begin{codeexample}[code only]
\pgfkeys{/some path/my key=foo}
...
\pgfgdbeginscope
  ...
\pgfgdendscope
\end{codeexample}
  Then, inside the graph drawing scope, a call to
\begin{codeexample}[code only]
   local myvalue = digraph.options['/some path/my key']
\end{codeexample}
  will set |myvalue| to |'foo'|.
  
  \medskip
  \noindent\textbf{Conversions.}
  In many cases, when you specify a graph parameter, you will not wish
  the original \meta{value} to be passed to the algorithm. For
  instance, suppose we write 
\begin{codeexample}[code only]
\pgfkeys{ /some path/width/.graph parameter=string }
\end{codeexample}
  We could now say |/some path/width=20pt+2pt|. Then, inside the 
  algorithm call to the function |options['/some path/width']| would yield the
  string |'20pt+2pt'|. However, inside the algorithm, it would be
  somewhat preferable to have access to the value |22.0| rather than the
  string |'20pt+2pt'|. Similary, when the width is |1in|, the algorithm
  will   prefer to get passed the number |72.27| instead of |'1in'|.

  What we need is a \emph{conversion} of the value passed to the key
  before it is stored as a graph parameter. This is done by setting
  a \meta{conversion} when defining the key as a graph parameter. 
  
  Whenever a \meta{value} is assigned to the \meta{key}, the
  \meta{conversion} will be executed with path prefix
  |/graph drawing/conversions/|. The \meta{conversion} gets passed the
  \meta{value} and should store the ``result'' of the
  conversion in the macro |\pgfgdresult|. The contents of this macro is
  the text that will actually be passed down to the algorithm.

  As an example, let us have a look at a math conversion. This can be
  achieved as follows:
\begin{codeexample}[code only]
\pgfkeys{    
  /graph drawing/conversions/number/.code={
    \pgfmathparse{#1}                % Parse the <value>...
    \let\pgfgdresult\pgfmathresult   % and store the result in \pgfgdresult
  }
}
\end{codeexample}

  The following conversion are available:
  \begin{key}{/graph drawing/conversions/string=\meta{string}}
    Put the argument in single quotes and apply |\luaescapestring| to \meta{string}.
  \end{key}
  \begin{key}{/graph drawing/conversions/raw=\meta{string}}
    No conversion at all is applied. This means that \meta{string} is
    used as raw Lua code. This makes it easy to define, for instance,
    functions.
  \end{key}
  \begin{key}{/graph drawing/conversions/boolean=\meta{value}}
    Return |true| in case \meta{value} is |true|, and |false| in all
    other cases.
  \end{key}
  \begin{key}{/graph drawing/conversions/number=\meta{math expression}}
    Passes \meta{math expression} to |\pgfmathparse|.    
  \end{key}
  \begin{key}{/graph drawing/conversions/direction=\meta{direction}}
    The \meta{direction} may either be one of the directions |up|,
    |down|, |left|, |right|, |north|, |south|, |east|, |west|,
    |north east|, |north west|, |south east|, |south west|, or an
    angle. The result is always a number, so |south| would be replaced
    by |-90| just as |-45*2| would be.
  \end{key}
  \begin{key}{/graph drawing/conversions/coordinate=\meta{coordinate}}
    The \meta{coordinate} should have the form
    |(|\meta{number}|pt,|\meta{number}|pt)|. It is converted to the
    format |{|\meta{number}|, |\meta{number}|}|, that is, to a Lua
    array of length~2.

    When you load the \tikzname\ library |graphdrawing| this
    conversion is overwritten by a more powerful conversion: You can
    then pass any \meta{coordinate} that is understood by
    \tikzname. It will still be converted into an
    array of length~2.
  \end{key}
  \begin{key}{/graph drawing/conversions/table with node keys=\meta{table}}
    The \meta{table} will first be parsed in Lua syntax, resulting in
    a Lua table. We distinguish two cases, depending on which kind of
    keys are present in the table:

    \begin{enumerate}
    \item Suppose that a key--value pair is of the form
      \meta{string}|=|\meta{something}. This happens, for instance,
      when you use |{foo=5, ["a b"]="six"}| as your \meta{table}. In this
      case, there will be two such pairs in the \meta{table}, namely
      the key |"foo"| with the value |5| (a number) and the key
      |"a b"| with the value |"six"| (a string).

      Now, the key--value pair will be converted to a new key--value
      pair. The value will be the same as before, but the key \meta{string}
      will be replaced by the vertex object whose |name| is the
      \meta{string}.
    \item Now suppose that a key--value pair is of the form
      \meta{number}|=|\meta{something}. This happens, for instance,
      when you use |{5, "six"}| as your \meta{table}, resulting in 
      two pair, one with the key |1| and the value |5| and one with
      the key |2| and the value |"six"|.

      In this case, once more only the key of the key--value pair will
      converted. This time, if the key is the number $i$, it will be
      replaced by the $i$th vertex of the syntactic digraph. If there
      are not (yet) this many vertices, an error is raised.
    \end{enumerate}
    Using the above rules, all keys of the \meta{table} get replaced
    by vertices (or errors occur). In the end, a new table results
    that maps vertex keys to values. It is this value which gets
    stored in the |options| array of the vertex or node.

    As an example, suppose we declare the following key:
\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{
  evolutionary distances/.node parameter=table with node keys
}
...
\tikz \graph [phylogenetic tree layout] {
  a, b, c, d; % Forward declaration of all nodes

  a[evolutionary distances={  0, 100, 200, 20}];
  b[evolutionary distances={100,   0, 250, 70}];
  c[evolutionary distances={200, 250,   0, 90}];
  d[evolutionary distances={ 20,  70,  90,  0}];
};
\end{codeexample}
    The result is that |a.options['/graph drawing/evolutionary distances']|
    is a table |t| where, for instance, |t[c] == 200| holds, assuming
    that |c| is the object representing the vertex named~|c|.
  \end{key}
  
  \medskip
  \noindent\textbf{Default values.}
  When a graph parameter is not set at all, the |options| table will
  be empty. For most keys, however, a default
  value should be set, such as, say, |1cm| for a node distance. You
  \emph{cannot} say |node distance/.initial=1cm| for a graph
  parameter |node distance| as one might expect since graph parameters
  are not normal keys. In principle, you could just say
  |node distance=1cm| in some outer scope to setup a default value for the
  key. However, due to the way graph parameters are implemented, if
  this were done for every graph parameter, huge lists of graph
  parameters would be passed around between \pgfname\ and Lua for each
  graph, even when the parameters are not used at all.

  For this reason, there is a special handler that allows you to setup
  initial values for graph parameters:
  \begin{handler}{{.parameter initial}|=|\meta{value}}
    Use this key handler instead of |.initial| to assign an initial value
    to a graph parameter. What will happen is that on the Lua layer,
    the passed \meta{value} is stored in a special table that will be
    used as a meta-table for all |options| object. This means that
    whenever the \meta{key} is not explicitly set by the user, the
    \meta{value} will be returned when you access an |options| table.

    The \meta{value} gets passed through the \meta{conversion} of the
    graph parameter before it is stored.

    \emph{Remark:} Since the \meta{value} is passed down and managed
    by Lua, changing the initial value is always ``global.'' In
    particular, the values will not revert at the end of \TeX\
    scope. Indeed, trying to call |.parameter initial| twice for the
    same key will result in an error. In order to locally change the
    value of a key, just say |key=value|; use
    |key/.parameter initial=value| only once right after the key has
    been created and use it only if the key ``really has'' a good
    default value. 
\begin{codeexample}[code only]
\pgfgdset{
  node distance/.graph parameter=number,
  node distance/.parameter initial=1cm
}
\end{codeexample}
  \end{handler}
\end{handler}

\begin{handler}{{.node parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} In \tikzname, when you write |node [foo=bar] {...}|,
  the option |foo| is executed before |\pgfnode| is called
  internally. This means that if foo is a node parameter the ideal
  place to set it is, indeed, as an option of the node -- which is
  exactly what people expect.
\end{handler}

\begin{handler}{{.edge parameter}|=|\opt{\meta{conversion}}}
  This key works like |.graph parameter|, only it
  affects node parameters rather than graph parameters.

  \emph{Remark:} When |\pgfgdedge| is executed, see also its
  documentation, it will ``tentatively'' execute its options. The only
  purpose of this ``tentative option execution'' is that options that
  are edge parameters get setup before the snapshot of the edge
  options is taken.  
\end{handler}


\begin{handler}{{.node or graph parameter}|=|\opt{\meta{conversion}}}
  This key works like |.node parameter| inside a graph drawing scope,
  otherwise it works like |.graph parameter|.
\end{handler}

\begin{handler}{{.edge or graph parameter}|=|\opt{\meta{conversion}}}
  As above, only for edges.
\end{handler}


\subsubsection{Accumulating Parameters}

Normally, when a parameter is used several times in a scope, the
value the option has in the resulting table is the  value given the
last time the parameter was used. While this is a sensible behaviour
for most keys, some options need to ``accumulate.'' For instance, a
node can be part of multiple |clusters|, so this key should
accumulate. In this case, the option table will store an array at the
key, containing all values used for the key.


\begin{handler}{{.accumulates}}
  Use this with a parameter to indicate that each use of this
  parameter in the current scope should add the given value to an
  array that is stored in the option.
\end{handler}


\subsubsection{Advanced Commands For Setting Parameters}

Graph drawing parameters should have the path
|/graph drawing| for systematic reasons. However, as a user we do not
wish to write things like (which would work):
\begin{codeexample}[code only]
\tikz [/graph drawing/algorithm=my algorithm,
       /graph drawing/my algorithm/foo=bar,  
       /graph drawing/blub=foobar] ...
\end{codeexample}
Rather, we would like to write
\begin{codeexample}[code only]
\tikz [my algorithm={foo=bar}, blub=foobar] ...
\end{codeexample}

In order to achieve this and still keep the parameters in the correct
key path, \emph{key forwarding} is used. For most graph parameters, a
key of the same name with the path |/tikz| is setup that will just
forward its value to the corresponding key in the |/graph drawing|
path. Indeed, additionally, another forward is also setup from a key
of the same name with the path |/tikz/graphs|. You could, in
principle, even add new paths for which such forwards are setup.

Note that forwarding often also works when the key with the path
|/tikz| already does something else. In this case, the ``something
else'' will be done first and then the key will forward additionally
to the graph drawing key.

Graph parameters come in too flavours: ``common'' and
``family-specific.'' A ``common'' graph parameter can be used by
several graph drawing algorithms. An example are orientation keys,
which can actually be applied to any graph in a postprocessing
step. In contrast, ``family-specific'' keys are only important for
one algorithm or only for algorithms from a small family of
algorithms. For instance, a ``stiffness'' for spring layout algorithms 
would only apply to, well, spring layout algorithms.

The common graph parameters reside in the path |/graph drawing|,
while the family-specific graph parameters reside in the path
|/graph drawing/|\meta{family name}. For common graph parameters,
forwarding will be setup in paths like |/tikz| or |/tikz/graphs|, so
you can use these keys directly. In contrast, no forwarding will be
setup for family-specific keys. Rather, these keys can be passed to the
algorithm's key, which will in turn executed the keys with the
prefix |/graph drawing/|\meta{family name}.

Since setting up the forwards manually is cumbersome, there are some
special commands that should help you with this. We begin with
commands for setting up common graph parameters, but first we need a
command for specifying the list of paths from which we wish to
forward.

\begin{command}{\pgfgdappendtoforwardinglist\marg{path}}
  Appends the \meta{path} (with trailing slash) to the forwarding
  list. This means that all new keys declared using
  |\pgfgddeclareforwardedkeys| or |\pgfgddeclarealgorithmkey| will
  define a forwarding from a key with the prefix \meta{path} to the
  corrsponding key. 

  If a key has already been defined using one of the command,
  forwarding from \meta{path} will also 
  be setup for this key (using a bit of magic\ldots).  
\end{command}


\begin{command}{\pgfgddeclareforwardedkeys\marg{prefix}\marg{list of key declarations}}
  Each element in the \meta{list of key declarations} should have the
  form \meta{key name}|/|\meta{action}. For each element the following
  keys are setup:

  \begin{itemize}
  \item \meta{prefix}|/|\meta{key name}|/|\meta{actions}
  \item Provided that \meta{prefix}|/|\meta{keyname} was just defined
    for the first time just now, for each \meta{path} in the current
    forwarding list, a forwarding is added from the key
    \meta{path}|/|\meta{key name} to is \meta{prefix}|/|\meta{keyname}.
  \end{itemize}
  Typically, namely when \tikzname\ is used, the forwarding list is
  set to |/tikz,/tikz/graphs|. This means that you can use the
  \meta{key name} both in the |/tikz| and also in the |/tikz/graphs|
  namespace.
\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{
  node distance/.graph parameter=number,
  node distance/.parameter initial=1cm
}
\end{codeexample}
\end{command}


\begin{command}{\pgfgddeclarealgorithmkey\marg{algorithm  key}\marg{algorithm family}\marg{options}}
  This command will setup the following keys:
  
  \begin{key}{/graph drawing/\meta{algorithm key}=\meta{more options}}
    When this key is executed, the \meta{options} that were passed to
    the |\pgfgddeclarealgorithmkey| command are executed first,
    tentatively, with the path prefix |/graph drawing|. Next, the
    \meta{more options}  are executed, but now with the path prefix
    |/graph drawing/|\meta{algorithm family}.

    Then, the following key is executed:
    \begin{key}{/graph drawing/at begin scope}
      This key does nothing by default, but it could be used to setup
      things (as is done in \tikzname) to start the graph drawing
      engine for the current scope. 
    \end{key}
  \end{key}

  Next, forwaring is setup from \meta{algorithm key} for all paths in
  the path list to |/graph drawing/|\meta{algorithm key}.
  
  The idea behind the \meta{algorithm family} is that several
  algorithms might share some keys. For
  instance, all spring-based algorithms are defined with the path
  prefix |/graph drawing/spring layout|. For them, the
  \meta{algorithm family} is set to |spring layout|.
\begin{codeexample}[code only]
\pgfgddeclarealgorithmkey
  {spring electrical}
  {spring layout}
  {
    algorithm=pgf.gd.force.SpringElectricalWalshaw2000,
    spring layout/temperature=0.95,
    spring layout/spring constant=0.01,
  }    
\end{codeexample}
\end{command}  



\subsection{Collections of Nodes and Edges}

\label{section-gd-collections}

A \emph{collection} is a pair consisting of a set of nodes and a set of
edges. Since the edges need not be between the nodes of the same
collection, collections are not subgraphs, but something more
``loose'' -- namely collections.

Collections are grouped into ``kinds'', that is, all collections
having the same kind will be grouped together. On the Lua layer, all
collections of the same kind can be accessed directly via a single
array; on the \pgfname\ layer, for each kind a separate key is available
to indicate that a node or an edge belongs to a collection. 

Collections serve two purposes: First, they can be seen as ``hints''
to graph drawing algorithms that certain nodes and/or edges ``belong
together''. For instance, collections of kind |same rank| are used
by the Sugiyama algorithm to group together nodes that should appear
at the same height of the output. Second, since collections are also
passed back to the \pgfname\ layer in a postprocessing step, they can be
used to render complicated concepts such as hyperedges (which are
just collections of nodes, after all) or subgraphs.


\begin{command}{\pgfgddeclarecollectionkind\marg{kind}\marg{layer}}
  This coammand has a number of effects. First, a key is defined:

  \begin{key}{/graph drawing/\meta{collection kind}=\meta{options}}
    \keyalias{tikz}
    \keyalias{tikz/graphs}
    When this key is used inside a graph drawing scope, all nodes and
    edges mentioned in the rest of 
    the current \TeX\ scope will belong to a new collection whose kind
    is \meta{kind}. This new collection may also have some local
    options, which are specified as an argument to the key. For
    instance, suppose you write
\begin{codeexample}[code only]
\pgfgddeclarecollectionkind{hyper}{0}
\graph {
  a, b, c, d;
  { [hyper={foo=bar}] a, b, c }
  { [hyper={red,green}] b, c, d }
};
\end{codeexample}

    In this case, the nodes |a|, |b|, |c| will belong to a collection of
    kind |hyper| and this collection will have the option |foo=bar|
    set. The nodes |b|, |c|, and |d| will (also) belong to another
    collection of the same kind |hyper|, but with the options |red| and
    |green| set.
    
    The \meta{options} passed to the key are exectued with the path
    prefix |/graph drawing|. The options must all be graph parameters,
    node parameters, or edge parameters.
    
    Normally, as claimed above, using the key will cause a new
    collection to be started inside the current \TeX\ group. However,
    this is not quite true:
  
    \begin{key}{/graph drawing/name=\meta{name}}
      You can use this key inside the options passed to the key. In this
      case, if a collection 
      of the same name has already been specified earlier (in some other
      group), the following nodes and edges get added to this earlier
      collection:
\begin{codeexample}[code only]
\graph {
  a, b, c, d;
  { [hyper={name=core}] a, b }
  { [hyper] b, c, d }
  { [hyper={name=core}] d }
};
\end{codeexample}

      In the above example, the collection |core| will be of kind |hyper|
      and will contain the nodes |a|, |b|, and |d|. A second (unnamed)
      collection of kind |hyper| will contain the nodes |b|, |c|, and
      |d|. Internally, unnamed collections get assigned a unique internal
      name.
    \end{key}
  \end{key}

  Let us next have a look at the further effects declaring a
  collection kind has: On the Lua layer, when the graph drawing engine
  gets warmed up, the collections of the input graph get ``sorted out''
  according to their kinds. In detail, the representation of the graph
  drawing scope has a table |collections| that has an entry for each
  collection \meta{kind}. (In case \meta{kind} contains a space or
  other strange characters, you have to access the |collections| table
  through a string index. For instance, to access the |same rank|
  collections, use |collections['same rank']|.)
    
  Each entry of the |collections| table is an array in which the
  collections of a certain kind are stored in the order they appear in
  the input. Each of these collections is itself a table, having the
  following fields: The |name| field contains the collection's name,
  either the one passed using the |name| key or the internal name
  created automatically. The |vertices| and |edges| fields each
  contain arrays of all objects being part of the collection.

  Once a graph drawing algorithms has computed node and edge
  placements, the binding layer will attempt to ``render'' all
  collections: For this, for each collection kind, the following keys
  are executed:

  \begin{key}{/graph drawing/\meta{kind}/begin rendering}
    This key is tried once for each kind, even if there are no
    collections of the kind.
  \end{key}
  \begin{key}{/graph drawing/\meta{kind}/render=\meta{options}}
    This key is tried once for each collection. Each time, the values
    stored in the |generated_options| table of the collection (if
    present) is passed as \meta{options}.
  \end{key}
  \begin{key}{/graph drawing/\meta{kind}/end rendering}
    This key is tried once for each kind.
  \end{key}
  
  The idea of the above is that you can setup certain collection kinds
  to be rendered in a special way. Suppose, for instance, you would
  like hyperedges to be rendered. In this case, a graph drawing
  algorithm should iterate over all collections of type |hyper| and
  compute some hints on how to render the hyperedge and store this
  information in the |generated_options| table of the hyperedge. Then,
  the key |/graph drawing/hyper/render| should be setup so that it
  contains some code that is able to read key--value pairs passed to
  it (which are the key--value pairs of the |generated_options| table)
  and use this information to nicely draw the hyperedge.

  The \meta{layer} parameter is used to specify the order
  in which the different collection kinds are rendered. The higher the
  number, the later the collection will be rendered. Thus, if there is
  a collection kind with layer number 10 and another with layer number
  20, all collections of the first kind will be rendered first,
  followed by all collections of the second kind.
  
  Collections whose layer kinds are non-negative get rendered
  \emph{after} the nodes and edges have already been rendered. In
  contrast, collections with a negative layer number get shown
  ``below'' the nodes and edges. Actually, they are also rendered
  after the nodes and edges have already been drawn, but they are a
  put in a box that is shipped out before the the box of the nodes and
  edges gets shipped out.

  The following shows the use of the |same rank| kind:
  \begin{codeexample}[]
\tikz [rounded corners] \graph [layered layout] {
    1972 -> 1976 -> 1978 -> 1980 -> 1982 -> 1984 -> 1986 -> 1988 -> 1990 -> future;
        
    { [same rank] 1972, Thompson };
    { [same rank] 1976, Mashey, Bourne },
    { [same rank] 1978, Formshell, csh },
    { [same rank] 1980, esh, vsh },
    { [same rank] 1982, ksh, "System-V" },
    { [same rank] 1984, v9sh, tcsh },
    { [same rank] 1986, "ksh-i" },
    { [same rank] 1988, KornShell ,Perl, rc },
    { [same rank] 1990, tcl, Bash },
    { [same rank] "future", POSIX, "ksh-POSIX" },

    Thompson -> { Mashey, Bourne, csh -> tcsh},
    Bourne -> { ksh, esh, vsh, "System-V", v9sh -> rc, Bash},
    { "ksh-i", KornShell } -> Bash,
    { esh, vsh, Formshell, csh } -> ksh,
    { KornShell, "System-V" } -> POSIX,
    ksh -> "ksh-i" -> KornShell -> "ksh-POSIX",
    Bourne -> Formshell,
    
    { [edge={draw=none}]
      Bash -> tcl,
      KornShell -> Perl
    }
  };
\end{codeexample}
\end{command}



\subsection{Events}
\label{section-gd-events}

\emph{Events} are used to pass information from the parser about the
syntactic structure of a graph to graph drawing algorithms. Consider,
for instance, a graph that is actually a tree in which some node
``misses'' its first child. In this case, the information that the
child is missing is neither part of any node (because the node is
missing, after all) nor is it an option of the whole graph. However,
events are created by the parser the allow an algorithm to reconstruct
the fact that the child is missing. Naturally, graph drawing
algorithms may choose to ignore events and most will.

Most of the creation and handling of events is done automatically. The
only reason you might wish to use the following commands is when you
write a ``parser extension'' together with a new graph drawing
algorithm. For instance, you might come up with new options that, when
used, trigger events.

\begin{command}{\pgfgdevent\marg{kind}\marg{parameter}}
  Creates a new |Event| object on the Lua layer whose |kind| field is
  set to \meta{kind} and the |parameters| field to \meta{parameter}.
  You must be inside a graph drawing scope to use this command.
\end{command}

\begin{command}{\pgfgdbegineventgroup\marg{parameter}}
  Starts an event group. This just means that an |Event| of kind
  |begin| is created with the given \meta{parameter}.
\end{command}

\begin{command}{\pgfgdendeventgroup}
  Ends an event group. This is done by adding an event of kind |end|
  without any parameters to the event string.
\end{command}

\begin{command}{\pgfgdeventgroup\marg{parameters}}
  Starts an event group just like |\pgfgdbegineventgroup|, but adds a
  corresponding closing |end| event at the end of the current \TeX\
  group (using |\aftergroup|).
\end{command}