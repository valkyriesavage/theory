% Copyright 2011 by Jannis Pohlmann
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\section{Implementing Graph Drawing Algorithms: Examples}
\label{section-gd-implementation-last}


\begin{tikzlibrary}{graphdrawing.examples}
  This package presents some examples of how different aspects of the
  graph drawing engine can be used. In particular, the algorithms of
  this package are not really meant to be used to layout graphs
  (although they can be used, in principle); rather you are invited to
  have a look at their implementation and to adapt them to your
  needs. 
\end{tikzlibrary}


\begin{gdalgorithm}{simple demo layout}{pgf.gd.examples.SimpleDemo}
  The algorithm is a ``hello world'' version of graph drawing: It
  arranges nodes in a circle (without paying heed to the sizes of the
  nodes or to the edges). In order to ``really'' layout nodes in a
  circle, use |circular layout|; the present layout is only intended
  to demonstrate how much (or little) is needed to implement a graph
  drawing algorithm.
\begin{codeexample}[code only]
-- File pgf.gd.examples.SimpleDemo

local SimpleDemo = pgf.gd.new_algorithm_class {
  works_only_on_connected_graphs = true,
}

function SimpleDemo:run()
  local g = self.digraph
  local alpha = (2 * math.pi) / #g.vertices

  for i,vertex in ipairs(g.vertices) do
    local radius = vertex.options['/graph drawing/node radius'] or g.options['/graph drawing/radius']
    vertex.pos.x = radius * math.cos(i * alpha)
    vertex.pos.y = radius * math.sin(i * alpha)
  end
end

return SimpleDemo
\end{codeexample}
Here is the \tikzname\ binding:
\begin{codeexample}[code only]
-- File pgflibrarygraphdrawing.examples
...  
\pgfgddeclareforwardedkeys{/graph drawing}{radius/.graph parameter=number,
                                           radius/.parameter initial=1cm}
\pgfgddeclarealgorithmkey{simple demo layout}
                         {simple demo layout}
                         {algorithm=pgf.gd.examples.SimpleDemo}
\end{codeexample}

\end{gdalgorithm}


\begin{gdalgorithm}{simple edge demo layout}{pgf.gd.examples.SimpleEdgeDemo}
  This algorithm shows how edges can be created by an algorithm. For
  this job, one can use the function |generateEdge|, which can be
  called during the run of the algorithm to create edges in the
  syntactic graph. The algorithm first does exactly the same as the
  simple demo layout, then it creates an edge for every node where the
  |new edges to| option is set. This option specifies numbers for each
  node and each time another node has a number greater than zero
  specified, an edge is created to this node.

  The example also demonstrates, how the |table with node keys|
  conversion works: Node and edge parameters with this conversion
  setup will take a table as input whose keys are node names or
  numbers. On the Lua side, this option can, however, be accessed as a
  table whose keys are vertices.

\begin{codeexample}[]
\tikz [simple edge demo layout]
\graph {
  a, b, c, d, e, f;
  
  e -> [red] f; % normal edge
  
  % Edges generated by the algorithm:
  a[new edges to={1,1,0,1,0,1}]; 
  b[new edges to={0,0,0,0,1,0}];
  c[new edges to={f=1}];
};
\end{codeexample}

The \tikzname\ binding is as follows:
\begin{codeexample}[code only]
\pgfgddeclareforwardedkeys{/graph drawing}{new edges to/.node parameter=table with node keys}
\pgfgddeclarealgorithmkey{simple edge demo layout}
                         {simple edge demo layout}
                         {algorithm=pgf.gd.examples.SimpleEdgeDemo}
\end{codeexample}

And the algorithm:
\begin{codeexample}[code only]
-- File pgf.gd.examples.SimpleEdgeDemo

-- Imports:
local LayoutPipeline = require "pgf.gd.control.LayoutPipeline"

-- Declaration:
local SimpleEdgeDemo = pgf.gd.new_algorithm_class {}

function SimpleEdgeDemo:run()
  -- Exactly the same code as in SimpleDemo above
  ...

  -- Now add some edges:
  for _,tail in ipairs(g.vertices) do
    local table = tail.options['/graph drawing/new edges to']
    for head, number in pairs(table or {}) do
      if number > 0 then
        LayoutPipeline.generateEdge (self, tail, head, {})
      end
    end
  end
end

return SimpleEdgeDemo
\end{codeexample}
\end{gdalgorithm}


\begin{gdalgorithm}{simple Huffman layout}{pgf.gd.examples.SimpleHuffman}
  This algorithm demonstrates how an algorithm can generate new
  nodes: The input graph should just consist of some nodes (without
  edges) and each node should have a |probability| key set. The nodes
  will then be arranged in a line (as siblings) and a Huffman tree
  will be constructed ``above'' these nodes. For the construction of
  the Huffman tree, new nodes are created and connected.

\begin{codeexample}[]
\tikz \graph [simple Huffman layout,
              level distance=7mm, sibling distance=8mm, grow'=up]
{
  a ["0.5",  probability=0.5],
  b ["0.12", probability=0.12],
  c ["0.2",  probability=0.2],
  d ["0.1",  probability=0.1],
  e ["0.11", probability=0.11]
};    
\end{codeexample}
  The file starts with some setups:
\begin{codeexample}[code only]
-- File pgf.gd.examples.SimpleHuffman

-- Import
local layered = require "pgf.gd.layered"
local LayoutPipeline = require "pgf.gd.control.LayoutPipeline"

--- A not-quite trivial implementation of a Huffman tree. Each node
--- must have a field "probability" set. They will be connected
--- according to the Huffman method. No attempt is made at creating a
--- good positioning of the tree nodes in this simple example.

local SimpleHuffman = pgf.gd.new_algorithm_class {
  growth_direction = 90
}

function SimpleHuffman:run()
  -- Construct a Huffman tree on top of the vertices...
\end{codeexample}

  Next comes a setup, where we create the working list of vertices
  that changes as the Huffman coding method proceeds:
\begin{codeexample}[code only]
  -- Shorthand
  local function prop (v) return v.storage[self].prop or v.options['/graph drawing/probability'] end
  
  -- Copy the vertex table, since we are going to modify it:
  local vertices = {}
  for i,v in ipairs(self.ugraph.vertices) do
    vertices[i] = v
  end
\end{codeexample}

  The initial vertices are arranged in a line on the last layer. The
  function |ideal_sibling_distance| takes care of the rather
  complicated handling of the (possibly rotated) bounding boxes and
  separations. The |storage[self]| is a table that can be used by
  algorithms to ``store stuff'' at a vertex or at an arc. In this
  case, we store the ``layer'' of the vertices here. The table will be
  accessed by |arrange_layers_by_baselines| to determine the ideal
  vertical placements.
\begin{codeexample}[code only]
  -- Now, arrange the nodes in a line:
  vertices [1].pos.x = 0
  vertices [1].storage[self].layer = #vertices
  for i=2,#vertices do
    local d = layered.ideal_sibling_distance(self, self.ugraph, vertices[i-1], vertices[i])
    vertices [i].pos.x = vertices[i-1].pos.x + d
    vertices [i].storage[self].layer = #vertices
  end
\end{codeexample}  

  Now comes the actual Huffman algorithm: Always find the vertices
  with a minimal probability\dots
\begin{codeexample}[code only]
  -- Now, do the Huffman thing...
  while #vertices > 1 do
    -- Find two minimum probabilities
    local min1, min2

    for i=1,#vertices do
      if not min1 or prop(vertices[i]) < prop(vertices[min1]) then
        min2 = min1
        min1 = i
      elseif not min2 or prop(vertices[i]) < prop(vertices[min2]) then
        min2 = i
      end
    end
\end{codeexample}
  \dots and connect them with a new node. This new node gets the
  option |HuffmanNode|. It is now the job of the higher layers to map
  this option to something ``nice''.
\begin{codeexample}[code only]
  -- Create new node:
    local p = prop(vertices[min1]) + prop(vertices[min2])
    local v = LayoutPipeline.generateNode(self, { generated_options = {"HuffmanNode"}})
    v.storage[self].prop = p
    v.storage[self].layer = #vertices-1
    v.pos.x = (vertices[min1].pos.x + vertices[min2].pos.x)/2
    vertices[#vertices + 1] = v
    
    LayoutPipeline.generateEdge (self, v, vertices[min1],
                                 {generated_options = {HuffmanLabel = "0"}})
    LayoutPipeline.generateEdge (self, v, vertices[min2],
                                 {generated_options = {HuffmanLabel = "1"}})

    table.remove(vertices, math.max(min1, min2))
    table.remove(vertices, math.min(min1, min2))
  end
\end{codeexample}
  Ok, we are mainly done now. Finish by computing vertical placements
  and do formal cleanup.
\begin{codeexample}[code only]
  layered.arrange_layers_by_baselines(self, self.ugraph)
end

return SimpleHuffman
\end{codeexample}
\end{gdalgorithm}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual-pdftex-version"
%%% End: 
